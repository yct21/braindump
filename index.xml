<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ðŸª´ Brain Dump on Braindump</title><link>https://braindump.github.io/</link><description>Recent content in ðŸª´ Brain Dump on Braindump</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://braindump.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>alignment (rust)</title><link>https://braindump.github.io/alignment-rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/alignment-rust/</guid><description>All values in [[rust|Rust]] have an alignment and size.
The alignment specifies what addresses are valid to store the value at.</description></item><item><title>async/await</title><link>https://braindump.github.io/async-await/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/async-await/</guid><description>[!todo] todo:
relationship with future trait The async/await are syntax sugars for [[asynchronous programming-rust|asynchronous programming]] in Rust.</description></item><item><title>asynchronous executor</title><link>https://braindump.github.io/asynchronous-executor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/asynchronous-executor/</guid><description> [!todo] Todo:
Replace this stub note with real content</description></item><item><title>asynchronous programming (rust)</title><link>https://braindump.github.io/asynchronous-programming-rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/asynchronous-programming-rust/</guid><description>[!todo] Todo:
compare with other concurrent programming model Asynchronous programming is a concurrent programming model to run multiple tasks concurrently with non-blocking interfaces.</description></item><item><title>borrow checker</title><link>https://braindump.github.io/borrow-checker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/borrow-checker/</guid><description>[[rust|Rust]] implements an affine type system with borrow checker to keep track of a [[variable|variable&amp;rsquo;s]] state, and prevent invalid changes of the state.</description></item><item><title>dynamic sized type</title><link>https://braindump.github.io/dynamic-sized-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/dynamic-sized-type/</guid><description>Some types in [[rust|Rust]] does not have a size known at compile time. They are called dynamic sized types, and cannot implement Sized trait.</description></item><item><title>future</title><link>https://braindump.github.io/future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/future/</guid><description>A future represents an [[asynchronous programming|asynchronous]] computation that can produce a value at some time.
In rust a future is a type or value of type that implements std::future::Future trait.</description></item><item><title>interior mutability</title><link>https://braindump.github.io/interior-mutability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/interior-mutability/</guid><description>In [[rust|Rust]] some types provide interior mutability, that allows mutating a value through a [[reference-rust|shared reference]].
These types normally fall into two categories:</description></item><item><title>leaf future</title><link>https://braindump.github.io/leaf-future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/leaf-future/</guid><description>A leaf future is a [[future]] without any inner futures. It directly represents some resource that may not yet be ready to return a result.</description></item><item><title>lifetime</title><link>https://braindump.github.io/lifetime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/lifetime/</guid><description>A lifetime is a name for a region of code that some reference must be valid for.
[[borrow checker|Borrow checker]] would trace the path of a reference from where it borrows value from the owner, to the point of each access, and make sure there are no conflicting uses along that path.</description></item><item><title>memory (rust)</title><link>https://braindump.github.io/memory-rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/memory-rust/</guid><description>In [[rust]] programming, a program may have access to a stack, a heap, registers, text segments, memory-mapped registers, memory-mapped files, and perhaps nonvolatile RAM.</description></item><item><title>ownership</title><link>https://braindump.github.io/ownership/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/ownership/</guid><description>Rust&amp;rsquo;s [[memory|memory model]] centers on the idea that all values have a single owner. Exactly one place] is responsible for ultimately deallocating each value.</description></item><item><title>pin</title><link>https://braindump.github.io/pin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/pin/</guid><description>[!todo] Todo:
no-alias Pin is a smart pointer. It wraps another pointer and declares that its pointee has a stable location in memory, and cannot be moved elsewhere or deallocated before Pin is dropped, unless it wraps a types that implements Unpin.</description></item><item><title>reference (rust)</title><link>https://braindump.github.io/reference-rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/reference-rust/</guid><description>A reference is a pointer that come with an additional contract for how it can be used.
Rust allows the owner of a value to lend out that value to others without giving up [[ownership]] with a reference.</description></item><item><title>Rust</title><link>https://braindump.github.io/rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/rust/</guid><description>[!todo] Todo:
How to be memory safe Rust is a programming language that emphasizes performance, type safety, and memory safety.</description></item><item><title>trait</title><link>https://braindump.github.io/trait/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/trait/</guid><description>[!todo] Todo:
details A trait is a sort of interface that defines some behavior.</description></item><item><title>unsafe (rust)</title><link>https://braindump.github.io/unsafe-rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/unsafe-rust/</guid><description>Unsafe is the mechanism that Rust provides to take advantage of the invariants that, for whatever reason, the compiler cannot check.</description></item><item><title>wide pointer</title><link>https://braindump.github.io/wide-pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://braindump.github.io/wide-pointer/</guid><description>A wide pointer is a pointer that contains an extra word-sized field that gives the additional information about the value it points.</description></item></channel></rss>