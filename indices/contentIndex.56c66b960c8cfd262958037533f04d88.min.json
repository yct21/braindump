{"/":{"title":"🪴 Brain Dump","content":"\nYet another knowlege repository managed by obsidian.\n\n---\n\n- [tag: Rust](/tags/rust) / [[rust|Rust]]\n","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":[]},"/alignment-rust":{"title":"alignment (rust)","content":"\nAll values in [[rust|Rust]] have an _alignment_  and size.\n\nThe alignment specifies what addresses are valid to store the value at. It is measured in bytes, and always a power of 2.\n\nAll values must be at least byte aligned. Some value have stringent alignment due to CPU and memory system that access memory in blocks larger than a single block.\n\n---\n\n\u003e [!question]- Why should we care about alignment? \n\u003e \n\u003e Operations on data that is not aligned are referred to as misaligned accesses and can lead to poor performance and bad concurrency problems. For this reason, many CPU operations require, or strongly prefer, that their arguments are naturally aligned. A naturally aligned value is one whose alignment matches its size.\n\n\u003e [!question]- How could I check a value's alignment?\n\u003e \n\u003e It can be checked with `std::mem::align_of_val` function.","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust"]},"/async-await":{"title":"async/await","content":"\n\u003e [!todo] todo:\n\u003e \n\u003e - [ ] relationship with future trait\n\n---\n\nThe `async/await` are syntax sugars for [[asynchronous programming-rust|asynchronous programming]] in Rust. \n\n- An `async fn` declares a function that return a value that implements a [`Future` trait](future.md). \n```rust\n// `foo()` returns a type that implements `Future\u003cOutput = u8\u003e`. \n// `foo().await` will result in a value of type `u8`.\nasync fn foo() -\u003e u8 { 5 }\n```\n- An `async` block declares a type that implements a `Future` trait.\n```rust\n```rust\nfn bar() -\u003e impl Future\u003cOutput = u8\u003e {\n    // This `async` block results in a type that implements \n    // `Future\u003cOutput = u8\u003e`.\n    async {\n        let x: u8 = foo().await;\n        x + 5\n    }\n}\n```\n\n\u003e [!question] Why do we need `async/await` syntax?\n\u003e \n\u003e It preserves look and feel of ordinary synchronous programming.\n\n## How does compiler generate code for async function or block?\n\nA future constructed with async/await syntax is implemented as a generator with a state machine.\n\n\u003e [!info] Generator\n\u003e\n\u003e A generator is a routine that can be used to control the iteration behavior of a loop. \n\u003e \n\u003e - When running, it can yield control back to caller (and optionally return a value). \n\u003e - When this generator is called again, it resumes its control flow from where it last yielded.\n\u003e\n\n### From `await` to state machine\n\nThe `await` syntax separates a future into several continuations. Given code below:\n\n```rust\nasync fn some_async_process\u003cT\u003e(rx: Receiver\u003cT\u003e, tx: Sender\u003cT\u003e) {\n    let data1 = Step1::process().await;\n    let data2 = Step2::process(\u0026data1).await;\n    let data3 = Step3::process(\u0026data2).await;\n\n    while let Some(t) = rx.next().await {    \n        tx.send(Step4::process(\u0026t, \u0026data3).await).await;\n    }\n}\n```\n\nThe compiler would generate a state machine like this:\n\n![[images/async-await-statemachine.png]]\n\nEach node in state machine can be treated like a variant of enum. It would also store all variables in the continuation as its internal data. This makes this state machine like a enumeration:\n\n\u003e [!tip] This code is inaccurate.\n\u003e \n\u003e The code below is a demonstration of the mechanism. Rustc would perform several optimizations during a real process.\n\n```rust\n// Please replace variables below with its type\nenum StateMachine {\n    Begin(rx, tx),\n    Step1(rx, tx),\n    Step2(rx, tx, data1),\n    Step3(rx, tx, data1, data2),\n    RxNext(rx, tx, data1, data2, data3),\n    Send(rx, tx, data1, data2, data3, t),\n    End,\n}\n```\n\nThe enumeration is generated so that the future could match its variants.\n\n### Match the enumeration\n\nWhen running (polling) a future, it matches its variants first, then decides which continuation to run. \n\nIt works like this:\n\n```rust\n// Actually it would compiles to Future::poll\nfn some_async_process\u003cT\u003e(rx: Receiver\u003cT\u003e, tx: Sender\u003cT\u003e) {\n    let state = StateMachine::Begin(rx, tx);\n    while state != StateMachine::End {\n        match state {\n            // do computations and modify `state` in each continuation\n            Begin =\u003e { ... },\n            Step1 =\u003e { ... },\n            Step2 =\u003e { ... },\n            Step3 =\u003e { ... },\n            RxNext =\u003e { ... },\n            Send =\u003e { ... },\n        }\n    }\n}\n```\n\nThe code above describes how program decides where to resume. What happens when it yields is described in [[future|Future]].\n\n\n\n\n","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust","asyncronous-programming"]},"/asynchronous-executor":{"title":"asynchronous executor","content":"\n\u003e [!todo] Todo:\n\u003e - [ ] Replace this stub note with real content\n\n---","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","asyncronous-programming"]},"/asynchronous-programming-rust":{"title":"asynchronous programming (rust)","content":"\n\u003e [!todo] Todo:\n\u003e - [ ] compare with other concurrent programming model\n\n---\n\n_Asynchronous programming_ is a concurrent programming model to run multiple tasks concurrently with non-blocking interfaces.\n\nIn [[rust|Rust]] asynchronous programming is implemented through [[future|Future]] and [[async-await|async/await syntax]] to  preserving look and feel of ordinary synchronous programming.\n\nSpecifically:\n\n- Rustc would [[async-await#How does compiler generate code for async function or block?|generate code]] for `async` function or closure.\n- Rust standard library provides interfaces like `Future` or `Waker`.\n- The asynchronous runtimes are provided by 3rd party library like [tokio](https://tokio.rs) or [async-std](https://github.com/async-rs/async-std). \n\nMost 3rd party asynchronous runtime are implemented with reactor-executor pattern that run tasks as stackless coroutines, since `async/await` syntax and `Future` trait are tailored into this approach.\n\n\u003e [!question] Why Rust community prefers stackless coroutine\n\u003e \n\u003e Rust community adopted stackless coroutine for these reasons:\n\u003e 1.  It's easy to convert normal Rust code to a stackless coroutine using [[async-await|async/await]] as keywords (it can even be done using a macro).\n\u003e 2.  No need for context switching and saving/restoring CPU state.\n\u003e 3.  No need to handle dynamic stack allocation.\n\u003e 4.  Very memory efficient.\n\u003e 5.  Allows us to borrow across suspension points.","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust","asyncronous-programming"]},"/borrow-checker":{"title":"borrow checker","content":"\n[[rust|Rust]] implements  an _affine type system_ with _borrow checker_ to keep track of a [[variable|variable's]] state, and prevent invalid changes of the state.\n\nCompiler could trace a value that owned by a variable by tracking the variable, which forms the **flow** of this value. Whenever the variable is accessed, borrow checker analyze if the access is valid in the flow. \n\nA value has these states:\n\n- uninitialized\n- normal\n- value shared borrowed\n- value exclusively borrowed\n- value moved (not applicable to type that implements `Copy`)\n\nA value could enter state `shared borrowed` or `exclusively borrowed` when it get referenced. Other status changes most happen during an assignment.\n\n## Status tracking during an assignment\n\nThe borrow checker enforces different rules of assignment depending on whether the type of the variable implements `Copy` trait or not.\n\n### Types implements `Copy` trait\n\nWhen the type of a variable implements `Copy` trait, the variable is at one or several of:\n\n- uninitialized\n- normal\n- value shared borrowed\n- value exclusively borrowed\n\n\u003e [!question] How could a place be at several states at the same moment?\n\u003e \n\u003e A place may enters multiple states due to branches or loops.\n\u003e ```rust\n\u003e let mut x = Box::new(42);\n\u003e let r = \u0026x; // x is shared borrowed\n\u003e if rand() \u003e 0.5 {\n\u003e     *x = 4;  // x ends the lease here\n\u003e } else {\n\u003e     println!(\"{}\", r); // access of reference\n\u003e }\n\u003e \n\u003e // now x is at both states of normal and shared borrowed\n\u003e ```\n\nDuring an assignment of `a = b` with type `T` that implements `Copy`, compiler would check:\n\n- `a` has to be mutable or at state of `uninitialized`.\n```rust\nlet a = 1;\nlet b = 2;\na = b; // error: cannot assign twice to a immutable value\n```\n- If `a` is at state of `value shared borrowed` or `value exclusively borrowed`, `a` should be able to end the lease immediately.\n```rust\nlet mut a = 1;\nlet ref_a = \u0026a;\nlet b = 2;\na = b; // error: cannot assign to `a` because it is borrowed\nprintln!(\"{}\", ref_a); \n```\n- `b` should not be at state of `uninitialized`.\n- If `b` is at state of `value exclusively borrowed`, `b` should be able to end the lease immediately.\n```rust\nlet mut a = 1;\nlet mut b = 42;\nlet ref_b = \u0026mut b;\na = b; // error: cannot use `b` used it is mutably borrowed\nprintln!(\"{}\", ref_b);\n```\n\nAfter the assignment, bit-wisely copy the value from `b` to `a`, and `a` enters state `normal`.\n\n### Types not implement `Copy` trait\n\nWhen the type does not implement `Copy` trait, the variable is at one or several states of:\n\n- uninitialized\n- normal\n- value shared borrowed\n- value exclusively borrowed\n- value moved\n\nDuring an assignment of `a = b` with type `T` that does **not** implements `Copy`, compiler would check **all** the rules for [[borrow checker#What if it implements `Copy`?|Copy types]]. Additionally:\n\n- `b` should not at state of `value moved`\n- When `b` is at state of `value shared borrowed`, `b` should able to end the lease immediately.\n\nAfter the assignment:\n\n1. Drop the value owned by `a` if it does. \n2. Bit-wisely copy the value from `b` to `a`\n3. `a` enters state `normal`.\n4. `b` enters state `value moved`.\n\n","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust"]},"/dynamic-sized-type":{"title":"dynamic sized type","content":"\nSome types in [[rust|Rust]] does not have a size known at compile time. They are called _dynamic sized types_, and cannot implement `Sized` trait.\n\nThe most common dynamic sized types are:\n- [[trait object]]\n- [[slice]]","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust"]},"/future":{"title":"future","content":"\nA future represents an [[asynchronous programming|asynchronous]] computation that can produce a value at some time. \n\nIn rust a future is a type or value of type that implements `std::future::Future` trait.\n\n\u003e [!question] Why do we need a `Future` trait in standard library?\n\u003e \n\u003e The `Future` trait are building blocks of asynchronous programming in Rust. They provides a standardized interface for user and library authors. Without it, all libraries with an asynchronous interface may come with their own `polling` method, all with different names, signatures and return types.\n\n## How do we use future?\n\nMost asynchronous runtime would come up with their own [[leaf-future|leaf future]] as API. And many libraries have asynchronous interfaces. We could use [[async-await]] to compose the these APIs into a task and run it on the runtime.\n\n```rust\nuse mini_redis::{client, Result};\nuse tokio::fs::File;\nuse tokio::io::{self, AsyncReadExt};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    // Leaf futures from tokio\n    let mut f = File::open(\"data.txt\").await?;\n    let mut buffer = [0; 10];\n    let n = f.read(\u0026mut buffer[..]).await?;\n\n    // Asynchronous APIs from mini-redis\n    let mut client = client::connect(\"127.0.0.1:6379\").await?;\n    client.set(\"hello\", \"world\".into()).await?;\n    let result = client.get(\"hello\").await?;\n    println!(\"got value from the server; result={:?}\", result);\n\n    Ok(())\n}\n\n```\n\n## How does a future run?\n\n### Polling\n\nFutures in Rust use a `poll` based approach. The asynchronous interface of Rust is a method that returns a `Poll` type, which is actually the result of polling:\n\n```rust\n// here your result or come back later\nenum Poll\u003cT\u003e {\n    Ready(T),\n    Pending\n}\n```\n\nThe `Future` trait is an abstraction over this pattern:\n\n```rust\npub trait Future {\n    type Output;\n\n    fn poll(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e;\n}\n```\n\nCalling `poll` method of a future would drive the future as far towards completion as possible. When it returns a `Poll` struct as result, it tells the caller that the result is ready or not. When it is not ready, the caller could do something else in the meantime rather than having to go to sleep until some particular situation changes.\n\nA typical asynchronous runtime would poll the future at some appropriate time during managing the lifecycle of this future.\n\n### A future's lifecycle\n\nA typical asynchronous runtime (tokio or async-std) that implements reactor-executor pattern would manage a future with theses phases:\n\n1. Poll phase: The future is polled by an [[asynchronous executor|executor]], until a point that can no longer make progress. When it returns `Poll::Ready`, the future is completed with this outcome, otherwise it goes to wait phase.\n2. Wait phase: The future is registered in an event queue by [[asynchronous reactor|reactor]] and goes inactive, until some event happens that push the future to wake phase.\n3. Wake phase: Some event happens. The waker calls `waker()` to indicate the executor that the future is ready to be polled again. Then the executor would update its internal queue to hold this future.  When the future is scheduled, it goes to poll phase.\n\nThe runtime drives a future into its next phase of lifecycle until it completes. That's how a future runs.\n\n\u003e [!question] A waker is supposed to call `wake` on future when some event happens. How does this work exactly?\n\u003e \n\u003e It depends on the future.\n\u003e \n\u003e When a future returns `Poll::pending` from polling and enters wait phase, it is the future's responsibility to ensure that something calls `wake` on the provided `Waker` when the future is able to make progress.\n\u003e\n\u003e The most common method are spawning another thread or using `Epoll`, `Kqueue` and `IOCP`.\n\n\u003e [!question] What is this `Context` in `poll`'s arguments?\n\u003e \n\u003e The `Context`  is a type that only wraps a [[asynchronous waker|waker]], but it gives flexibility for future evolution of API in rust.\n\n\u003e [!danger] Don't poll a future after it has returned `Poll::Ready`\n\u003e \n\u003e It is forbidden to poll a finished future. Going against it may cause panic or undefined behaviors.","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust","asyncronous-programming"]},"/interior-mutability":{"title":"interior mutability","content":"\nIn [[rust|Rust]] some types provide _interior mutability_, that allows mutating a value through a [[reference-rust|shared reference]].\n\nThese types normally fall into two categories:\n\n- `Mutex`, `RefCell`: These types contain safety mechanisms to ensure that the value it contains is lent out at most once (mutably) at any given moment.\n- `atomic`, `Cell`: These types does not lend out the inner value but provide methods to manipulate value in place.","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust"]},"/leaf-future":{"title":"leaf future","content":"\nA leaf future is a [[future]]  without any inner futures. It directly represents some resource that may not yet be ready to return a result. \n\n```rust\n// stream is a leaf-future \nlet mut stream = tokio::net::TcpStream::connect(\"127.0.0.1:3000\");\n```\n\nTypically leaf futures are provided by an asynchronous runtime as API. User of the runtime could combine these leaf futures with [[async-await]] syntax to construct complex tasks.","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust","asyncronous-programming"]},"/lifetime":{"title":"lifetime","content":"\nA _lifetime_ is a name for a region of code that some reference must be valid for.\n\n[[borrow checker|Borrow checker]] would trace the path of a reference from where it borrows value from the owner, to the point of each access, and make sure there are no conflicting uses along that path.\n\n\u003e [!info] Lifetime does not have to be contiguous.\n\u003e \n\u003e ```rust\n\u003e let mut x = Box::new(42);\n\u003e let r = \u0026x; // 'a\n\u003e if rand() \u003e 0.5 {\n\u003e     *x = 4;  // not 'a\n\u003e } else {\n\u003e     println!(\"{}\", r); // 'a\n\u003e }\n\u003e ```\n\u003e \n\u003e ```rust\n\u003e let mut x = Box::new(42);\n\u003e let mut z = \u0026x;    // 'a\n\u003e for i in 0..100 {\n\u003e     println!(\"{}\", z);  // 'a \n\u003e     x = Box::new(i);    // not 'a\n\u003e     z = \u0026x;             // 'a\n\u003e }\n\u003e \n\u003e println!(\"{}\", z);      // 'a\n\u003e ```","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust"]},"/memory-rust":{"title":"memory (rust)","content":"\nIn [[rust]] programming, a program may have access to a stack, a heap, registers, text segments, memory-mapped registers, memory-mapped files, and perhaps nonvolatile RAM. \n\n\u003e [!info] Rust does not yet have a defined memory model.\n\u003e \n\u003e  Various academics and industry professionals are working on various proposals, but for now, this is an under-defined place in the language[^rust reference: memory model].\n\n## Memory regions\n\nIt's responsibility of standard library to adapt the operating system. In a specialized environment, heap or even stack may not exist at all.\n\nThere are some general rules:\n\n-   There are no correspondences between a type to any memory region.\n-   Static items are allocated in static memory.\n-   [[variable|Variables]] in function are allocated in stack, except for temporaries being constant promoted, which are allocated in static memory.\n-   There is a global allocator in Rust that is responsible to allocate and free memory by adapting memory management for a process of the operating system .\n    -   Several types in standard library works tightly with global allocator (`Box` etc). They are considered to be API for programmers to access heap.\n-   Some places are considered to be a fraction of a bigger place, so that they are not related to some specific memory region.\n    -   fields in a `struct`\n    -   variables in a `async` function\n    -   variables captured by a closure\n\n[^rust reference: memory model]: https://doc.rust-lang.org/reference/memory-model.html","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust"]},"/ownership":{"title":"ownership","content":"\nRust's [[memory|memory model]] centers on the idea that all values have a single owner. Exactly one place] is responsible for ultimately deallocating each value.\n\nThis model is enforced through [[borrow checker]].\n\n\u003e [!question] Why Rust enforce this memory model?\n\u003e \n\u003e It allows Rust to be memory safe and efficient, while avoiding garbage collection. ","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust"]},"/pin":{"title":"pin","content":"\n\u003e [!todo] Todo:\n\u003e - [ ] no-alias\n\n---\n\n`Pin` is a smart pointer. It wraps another pointer and declares that its pointee has a stable location in memory, and cannot be moved elsewhere or deallocated before `Pin` is dropped, unless it wraps a types that implements `Unpin`.\n\nActually `Unpin` is an auto trait. So that most types are not limited by `Pin` even it is pinned. Therefore it is used in only a few situations.\n\n## Why do we need `Pin`?\n\n`Pin` was introduced to support self-referential structure for [[asynchronous programming-rust|asynchronous programming]].\n\nThe code below[^Self-referential types for fun and profit] contains a self-referential struct:\n\n```rust\nstruct ParseState { \n    data: [u8; 4096], // the buffer we're parsing \n    current_token: \u0026'data [u8], // current token during processing \n}\n```\n\nSince `current_token` is a slice from `data` field, we cannot assign a valid [[lifetime]] for `current_token` unless using `static`, which is not useful. Besides, when a value of `ParseState` is moved, `current_token` points to an invalid memory. \n\nIn pre-async days of Rust, there are some techniques to avoid self-referential structure, eg. guard field, or using index instead of pointer type. However all these techniques come with costs, like heap allocation or locks. Since rustc heavily relies on self-referential  when desugaring [[async-await]] syntax, those costs are not acceptable. \n\n```rust\nlet fut = async {\n    let mut x = xxx;\n    let p = \u0026mut x;\n    // `x` and `p` are saved in the same enum variant field \n    // enum Generator { DoSth1(x, p); End };\n    do_something1().await;\n    // when resumed, `x` and `p` should be still valid\n    do_something2(p); \n};\n\n```\n\nTherefore, we need `Pin` to ensure fields in self-referential structure to be valid whenever they are accessed before `Pin` is dropped.\n\n## How could `Pin` ensure its pointee to be unmovable?\n\nIt actually can't. `Pin` declares a contract. It does not have any mechanism to prevent its pointee to be moved.\n\n`Pin` is just a plain wrapper, without any compiler's black magic:\n\n```rust\npub struct Pin\u003cP\u003e {\n    pointer: P,\n}\n```\n\nThe \"unmovable\" contract should be guaranteed by the user of `Pin`, as described in document of `Pin::new_unchecked`:\n\n\u003e [Safety](https://doc.rust-lang.org/stable/std/pin/struct.Pin.html#safety)  \n\u003e This constructor is unsafe because we cannot guarantee that the data pointed to by `pointer` is pinned, meaning that the data will not be moved or its storage invalidated until it gets dropped. If the constructed `Pin\u003cP\u003e` does not guarantee that the data `P` points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.\n\n\n## What is `Unpin`?\n\n`Unpin` is an auto trait that is opt-in to implement. Any type `T` that implements `Unpin` trait can be safely moved after pinned with `Pin\u003cPointer\u003cT\u003e\u003e`.\n\n`Pin\u003c\u0026mut T\u003e` only provides `get_mut` for `T: Unpin`. It makes unique reference of  types that does not implements cannot be fetched through `Pin` API.\n\n\u003e [!info] `noalias` and `Unpin`\n\u003e \n\u003e Although `Pin` does not apply some black magic, the `Unpin` does. The compiler treats `Unpin` specially that for `T: !Unpin`, `\u0026mut T` does not have to be `no-alias`.[^pin-talk]\n\n[^pin-talk]: [不知道做点啥，今天来聊聊Pin吧](https://zhuanlan.zhihu.com/p/534089920)\n[^Self-referential types for fun and profit]: [Self-referential types for fun and profit](https://morestina.net/blog/1868/self-referential-types-for-fun-and-profit)\n\n\n","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust","asyncronous-programming"]},"/reference-rust":{"title":"reference (rust)","content":"\nA reference is a pointer that come with an additional contract for how it can be used.\n\nRust allows the owner of a value to lend out that value to others without giving up [[ownership]] with a reference.\n\nThere are two kinds of references:\n\n- shared reference \n- exclusive reference ","lastmodified":"2023-05-02T03:00:25.571014718Z","tags":["evergreen","rust"]},"/rust":{"title":"Rust","content":"\n\u003e [!todo] Todo:\n\u003e - [ ] How to be memory safe\n\n---\n\nRust is a programming language that emphasizes performance, type safety, and memory safety.","lastmodified":"2023-05-02T03:00:25.57501477Z","tags":["rust","evergreen"]},"/trait":{"title":"trait","content":"\n\u003e [!todo] Todo:\n\u003e - [ ] details\n\n---\n\nA trait is a sort of interface that defines some behavior.","lastmodified":"2023-05-02T03:00:25.57501477Z","tags":["evergreen","rust"]},"/unsafe-rust":{"title":"unsafe (rust)","content":"\n_Unsafe_ is the mechanism that Rust provides to take advantage of the invariants that, for whatever reason, the compiler cannot check.\n\n\u003e Crucially, unsafe code is not a way to skirt the various rules of Rust, like borrow checking, but rather a way to enforce those rules using reasoning that is beyond the compiler. When you write unsafe code, the onus is on you to ensure that the resulting code is safe[^rust for rustaceans].\n\n[^rust for rustaceans]: rust for rustaceans","lastmodified":"2023-05-02T03:00:25.57501477Z","tags":["evergreen","rust"]},"/wide-pointer":{"title":"wide pointer","content":"\nA wide pointer is a pointer that contains an extra word-sized field that gives the additional information about the value it points. \n\n---\n\n\u003e [!question] Why we need wide pointer?\n\u003e \n\u003e Rust requires types to be `Sized` nearly everywhere. This restriction is so common that `T: Sized` is bounded by default unless explicitly opt out with `T: ?Sized`.\nWhen dealing with a [[dynamic sized type]], a wide pointer is required for compiler to generate reasonable code for manipulate the value of DST.\n\n\u003e [!tip]  `Box` and `Arc` also support storing [[dynamic sized type]].\n\n\n\n","lastmodified":"2023-05-02T03:00:25.57501477Z","tags":["evergreen","rust"]}}